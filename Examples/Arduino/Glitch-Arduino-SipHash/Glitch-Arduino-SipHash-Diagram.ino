// Generated by Glitch!
// Wed Jun 7 12:55:00 2023

/*
** The SipHash algorithm written in Glitch!
*/

const static int C_ROUNDS[]  = {2, 4};

const static int D_ROUNDS[]  = {4, 8};

const static long C0  = long(0x736f6d6570736575L);

const static long C1  = long(0x646f72616e646f6dL);

const static long C2  = long(0x6c7967656e657261L);

const static long C3  = long(0x7465646279746573L);

int m_c_rounds_index  = 1;

int m_d_rounds_index  = 1;

long m_v0  = 0L;

long m_v1  = 0L;

long m_v2  = 0L;

long m_v3  = 0L;

const static int KEY_LENGTH  = 16;

byte m_key[KEY_LENGTH] ;

long byteArrayToLong(byte *bytes, int offset)
{
 if(bytes == NULL)
 {
  return(0L);
 }
 long value  = 0L;
 value  |= (((bytes[offset]) & (0xffL)));
 for(long i = 1; i <= 7L; i++)
 {
  value  |= (((((bytes[((i) + (offset))]) & (0xffL))) << (((8L) * (i)))));
 }
 return(value);
}

long rotl(long x, long b)
{
 return(((((x) << (b))) | (((x) >> (((64L) - (b)))))));
}

void round_f(void)
{
 m_v0  += (m_v1);
 m_v1 = rotl(m_v1, 13L);
 m_v1  ^= (m_v0);
 m_v0 = rotl(m_v0, 32L);
 m_v2  += (m_v3);
 m_v3 = rotl(m_v3, 16L);
 m_v3  ^= (m_v2);
 m_v2  += (m_v1);
 m_v1 = rotl(m_v1, 17L);
 m_v1  ^= (m_v2);
 m_v2 = rotl(m_v2, 32L);
 m_v0  += (m_v3);
 m_v3 = rotl(m_v3, 21L);
 m_v3  ^= (m_v0);
}

void SipHash(byte *key)
{
 if(key == NULL)
 {
  return;
 }
 for(int i = 0; i < KEY_LENGTH; i++)
 {
  m_key[key[i]] = i;
 }
}

void loop(void)
{
}

void setup(void)
{
}
