// Generated by Glitch!
// Tue Sep 12 22:18:58 2023

/* The SipHash algorithm written in Glitch! */

int m_c_rounds_index  = 1;

long m_v0  = 0L;

const static int C_ROUNDS[]  = {2, 4};

int m_d_rounds_index  = 1;

long m_v1  = 0L;

const static int D_ROUNDS[]  = {4, 8};

long m_v2  = 0L;

const static long C0  = long(0x736f6d6570736575L);

const static int KEY_LENGTH  = 16;

long m_v3  = 0L;

const static long C1  = long(0x646f72616e646f6dL);

const static long C2  = long(0x6c7967656e657261L);

byte m_key[KEY_LENGTH] ;

const static long C3  = long(0x7465646279746573L);

long rotl(long x, long b)
{
 return(((((x) << (b))) | (((x) >> (((64L) - (b)))))));
}

long byteArrayToLong(byte *bytes, int offset)
{
 if(bytes == NULL)
 {
  return(0L);
 }
 long value  = 0L;
 value  |= (((bytes[offset]) & (0xffL)));
 for(long i = 1; i <= 7L; i++)
 {
  value  |= (((((bytes[((i) + (offset))]) & (0xffL))) << (((8L) * (i)))));
 }
 return(value);
}

void round_f(void)
{
 m_v0  += (m_v1);
 m_v1 = rotl(m_v1, 13L);
 m_v1  ^= (m_v0);
 m_v0 = rotl(m_v0, 32L);
 m_v2  += (m_v3);
 m_v3 = rotl(m_v3, 16L);
 m_v3  ^= (m_v2);
 m_v2  += (m_v1);
 m_v1 = rotl(m_v1, 17L);
 m_v1  ^= (m_v2);
 m_v2 = rotl(m_v2, 32L);
 m_v0  += (m_v3);
 m_v3 = rotl(m_v3, 21L);
 m_v3  ^= (m_v0);
}

void SipHash(byte *key)
{
 if(key == NULL)
 {
  return;
 }
 for(int i = 0; i < KEY_LENGTH; i++)
 {
  m_key[i] = key[i];
 }
}

void hmac(byte *data, byte *key, long *output, long outputLength, long dataLength)
{
 /* Initialization */
 if(data == NULL || key == NULL || output == NULL)
 {
  return;
 }
 long k0  = byteArrayToLong(key, 0);
 long k1  = byteArrayToLong(key, 8);
 m_v0 = ((k0) ^ (C0));
 m_v1 = ((k1) ^ (C1));
 m_v2 = ((k0) ^ (C2));
 m_v3 = ((k1) ^ (C3));
 if(outputLength == 16)
 {
  m_v1  ^= (0xeeL);
 }
 /* Compression */
 int length1  = ((int(dataLength)) / (8));
 int length2  = C_ROUNDS[m_c_rounds_index];
 for(int i = 0; i < length1; i++)
 {
  long m  = byteArrayToLong(data, ((8) * (i)));
  m_v3  ^= (m);
  switch(length2)
  {
   case 2:
   {
    round_f();
    round_f();
    break;
   }
   case 4:
   {
    round_f();
    round_f();
    round_f();
    round_f();
    break;
   }
   default:
   {
    break;
   }
  }
  m_v0  ^= (m);
  m = 0L;
 }
 int offset  = ((((int(dataLength)) / (8))) * (8));
 long b  = ((dataLength) << (56L));
 switch(((int) dataLength) % 8)
 {
  case 7:
  {
   b  |= (((long(data[((offset) + (6))])) << (48L)));
  }
  case 6:
  {
   b  |= (((long(data[((offset) + (5))])) << (40L)));
  }
  case 5:
  {
   b  |= (((long(data[((offset) + (4))])) << (32L)));
  }
  case 4:
  {
   b  |= (((long(data[((offset) + (3))])) << (24L)));
  }
  case 3:
  {
   b  |= (((long(data[((offset) + (2))])) << (16L)));
  }
  case 2:
  {
   b  |= (((long(data[((offset) + (1))])) << (8L)));
  }
  case 1:
  {
   b  |= (long(data[((offset) + (0))]));
   break;
  }
  default:
  {
   break;
  }
 }
}

void loop(void)
{
}

void setup(void)
{
}
