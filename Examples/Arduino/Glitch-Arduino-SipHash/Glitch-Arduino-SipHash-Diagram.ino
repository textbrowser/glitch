// Generated by Glitch!
// Tue Oct 25 10:08:11 2022

/*
** The SipHash algorithm written in Glitch!
*/

const static int C_ROUNDS[]  = {2, 4};

const static int D_ROUNDS[]  = {4, 8};

const static long C0  = 0x736f6d6570736575L;

const static long C1  = 0x646f72616e646f6dL;

const static long C2  = 0x6c7967656e657261L;

const static long C3  = 0x7465646279746573L;

byte *m_key  = NULL;

int m_c_rounds_index  = 1;

int m_d_rounds_index  = 1;

long m_v0  = 0L;

long m_v1  = 0L;

long m_v2  = 0L;

long m_v3  = 0L;

const static int KEY_LENGTH  = 16;

long byteArrayToLong(byte *bytes, int offset)
{
 if(bytes == NULL)
 {
  return(0L);
 }
 long value  = 0L;
 value  |= (((bytes[offset]) & (0xffL)));
 for(long i = 1; i <= 7L; i++)
 {
  value  |= (((((((bytes[((i) + (offset))]) & (0xffL))) << (8L))) * (i)));
 }
 return(value);
}

long rotl(long x, long b)
{
 return(((((x) << (b))) | (((x) >> (((64L) - (b)))))));
}

void round_f(void)
{
 m_v0  += (m_v1);
 m_v1 = rotl(m_v1, 13L);
 m_v1  ^= (m_v0);
 m_v0 = rotl(m_v0, 32L);
 m_v2  += (m_v3);
 m_v3 = rotl(m_v3, 16L);
 m_v3  ^= (m_v2);
 m_v2  += (m_v1);
 m_v1 = rotl(m_v1, 17L);
 m_v1  ^= (m_v2);
 m_v2 = rotl(m_v2, 32L);
 m_v0  += (m_v3);
 m_v3 = rotl(m_v3, 21L);
 m_v3  ^= (m_v0);
}

void loop(void)
{
}

void setup(void)
{
}
